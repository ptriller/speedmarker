options {
    STATIC = false;
	DEBUG_PARSER = true;
}

PARSER_BEGIN(SpeedMarkerParser)
package de.soapwars.speedmarker;

import java.util.List;
import java.util.ArrayList;
import de.soapwars.speedmarker.ast.*;

public class SpeedMarkerParser extends SpeedMarkerParserBase {
}

PARSER_END(SpeedMarkerParser)

TOKEN_MGR_DECLS : {
    int curlyDepth = 0 ;
    java.util.List<StateBean> stateStack = new java.util.ArrayList<StateBean>();

	protected void swapState(int state) {
		popState();
		pushState(state);
	}

    protected void pushState(int state) {
        stateStack.add(new StateBean(curLexState, curlyDepth));
        SwitchTo(state);
    }

    protected void popState() {
      int state = stateStack.remove(stateStack.size()-1).state;
      SwitchTo(state);
    }

    protected void popIfCurly() {
        StateBean top = stateStack.get(stateStack.size()-1);
        if(curlyDepth == top.curly) popState();
    }
}

<DEFAULT>
SPECIAL_TOKEN:
{
    <NOPARSE_START: "<#noparse>"> { pushState(NOPARSE); }
}

<DEFAULT>
TOKEN:
{
     <TAG_MACROCALL_START: "<@">  { pushState(EXPRESSION); }
    |<TAG_MACROCALL_END: "</@">  { pushState(EXPRESSION); }
    |<TAG_ASSIGN_START: "<#assign"> { pushState(EXPRESSION); }
    |<TAG_ASSIGN_STOP: "</#assign"> { pushState(EXPRESSION); }
    |<TAG_ATTEMPT_START: "<#attempt"> { pushState(EXPRESSION); }
    |<TAG_ATTEMPT_STOP: "</#attempt"> { pushState(EXPRESSION); }
    |<TAG_BREAK_START: "<#break" > { pushState(EXPRESSION); }
    |<TAG_BREAK_STOP: "</#break" > { pushState(EXPRESSION); }
    |<TAG_CASE_START: "<#case"> { pushState(EXPRESSION); }
    |<TAG_CASE_STOP: "</#case"> { pushState(EXPRESSION); }
    |<TAG_COMPRESS_START: "<#compress"> { pushState(EXPRESSION); }
    |<TAG_COMPRESS_STOP: "</#compress"> { pushState(EXPRESSION); }
    |<TAG_DEFAULT_START: "<#default"> { pushState(EXPRESSION); }
    |<TAG_DEFAULT_STOP: "</#default"> { pushState(EXPRESSION); }
    |<TAG_ELSE_START: "<#else"> { pushState(EXPRESSION); }
    |<TAG_ELSE_STOP: "</#else"> { pushState(EXPRESSION); }
    |<TAG_ELSEIF_START: "<#elseif"> { pushState(EXPRESSION); }
    |<TAG_ELSEIF_STOP: "</#elseif"> { pushState(EXPRESSION); }
    |<TAG_ESCAPE_START: "<#escape"> { pushState(EXPRESSION); }
    |<TAG_ESCAPE_STOP: "</#escape"> { pushState(EXPRESSION); }
    |<TAG_FALLBACK_START: "<#fallback"> { pushState(EXPRESSION); }
    |<TAG_FALLBACK_STOP: "</#fallback"> { pushState(EXPRESSION); }
    |<TAG_FUNCTION_START: "<#function"> { pushState(EXPRESSION); }
    |<TAG_FUNCTION_STOP: "</#function"> { swapState(EXPRESSION); }
    |<TAG_FLUSH_START: "<#flush"> { pushState(EXPRESSION); }
    |<TAG_FLUSH_STOP: "</#flush"> { pushState(EXPRESSION); }
    |<TAG_FTL_START: "<#ftl"> { pushState(EXPRESSION); }
    |<TAG_FTL_STOP: "</#ftl"> { pushState(EXPRESSION); }
    |<TAG_GLOBAL_START: "<#global"> { pushState(EXPRESSION); }
    |<TAG_GLOBAL_STOP: "</#global"> { pushState(EXPRESSION); }
    |<TAG_IF_START: "<#if"> { pushState(EXPRESSION); }
    |<TAG_IF_STOP: "</#if"> { pushState(EXPRESSION); }
    |<TAG_IMPORT_START: "<#import"> { pushState(EXPRESSION); }
    |<TAG_IMPORT_STOP: "</#import"> { pushState(EXPRESSION); }
    |<TAG_INCLUDE_START: "<#include"> { pushState(EXPRESSION); }
    |<TAG_INCLUDE_STOP: "</#include"> { pushState(EXPRESSION); }
    |<TAG_LIST_START: "<#list"> { pushState(EXPRESSION); }
    |<TAG_LIST_STOP: "</#list"> { pushState(EXPRESSION); }
    |<TAG_LOCAL_START: "<#local"> { pushState(EXPRESSION); }
    |<TAG_LOCAL_STOP: "</#local"> { pushState(EXPRESSION); }
    |<TAG_LT_START: "<#lt"> { pushState(EXPRESSION); }
    |<TAG_LT_STOP: "</#lt"> { pushState(EXPRESSION); }
    |<TAG_MACRO_START: "<#macro"> { pushState(EXPRESSION); }
    |<TAG_MACRO_STOP: "</#macro"> { pushState(EXPRESSION); }
    |<TAG_NESTED_START: "<#nested"> { pushState(EXPRESSION); }
    |<TAG_NESTED_STOP: "</#nested"> { pushState(EXPRESSION); }
    |<TAG_NOESCAPE_START: "<#noescape"> { pushState(EXPRESSION); }
    |<TAG_NOESCAPE_STOP: "</#noescape"> { pushState(EXPRESSION); }
    |<TAG_NT_START: "<#nt" > { pushState(EXPRESSION); }
    |<TAG_NT_STOP: "</#nt" > { pushState(EXPRESSION); }
    |<TAG_RECOVER_START: "<#recover" > { pushState(EXPRESSION); }
    |<TAG_RECOVER_STOP: "</#recover" > { pushState(EXPRESSION); }
    |<TAG_RECURSE_START: "<#recurse" > { pushState(EXPRESSION); }
    |<TAG_RECURSE_STOP: "</#recurse" > { pushState(EXPRESSION); }
    |<TAG_RETURN_START: "<#return" > { pushState(EXPRESSION); }
    |<TAG_RETURN_STOP: "</#return" > { pushState(EXPRESSION); }
    |<TAG_RT_START: "<#rt" > { pushState(EXPRESSION); }
    |<TAG_RT_STOP: "</#rt" > { pushState(EXPRESSION); }
    |<TAG_SETTING_START: "<#setting" > { pushState(EXPRESSION); }
    |<TAG_SETTING_STOP: "</#setting" > { pushState(EXPRESSION); }
    |<TAG_STOP_START: "<#stop" > { pushState(EXPRESSION); }
    |<TAG_STOP_STOP: "</#stop" > { pushState(EXPRESSION); }
    |<TAG_SWITCH_START: "<#switch" > { pushState(EXPRESSION); }
    |<TAG_SWITCH_STOP: "</#switch" > { pushState(EXPRESSION); }
    |<TAG_T_START: "<#t" > { pushState(EXPRESSION); }
    |<TAG_T_STOP: "</#t" > { pushState(EXPRESSION); }
    |<TAG_VISIT_START: "<#visit" > { pushState(EXPRESSION); }
    |<TAG_VISIT_STOP: "</#visit" > { pushState(EXPRESSION); }
}

<DEFAULT,STRING_PARSE>
TOKEN:
{
    <EXPRESSION_START: "${" >  { pushState(EXPRESSION); curlyDepth++; }
    |<CONTENT: (~["<","$"])+ | ~[]>
}

<NOPARSE>
SPECIAL_TOKEN:
{
    <NOPARSE_END: "</#noparse>"> { popState(); }
}

<NOPARSE>
TOKEN:
{
    <UNPARSED_CONTENT: (~["<"])+ | ~[]>
}

<EXPRESSION>
TOKEN:
{
     <TAG_END: ">"> { popState(); }
    |<EMPTY_TAG: "/>"> { popState(); }
}
<EXPRESSION>
TOKEN:
{
     <QUOTE_RAW:  "r\"" > { pushState(IN_RAW_STRING); }
    |<QUOTE_DOUBLE: "\"" > { pushState(IN_DUAL_STRING); }
    |<QUOTE_SINGLE: "'" >  { pushState(IN_SINGLE_STRING); }
}

<EXPRESSION>
TOKEN:
{
     <NUMBERLITERAL: (["0"-"9"])+("."(["0"-"9"])+)? >
    |<BOOLEANLITERAL: "true" | "false" >
    |<DOUBLEQUEST: "??" >
    |<COMPARE: "==" >
    |<NOT_EQUALS: "!=" >
    |<LTE: "lte" | "\\lte" | "<=" | "&lt;=" >
    |<GTE: "gte" | "\\gte"  | "&gt;=" >
    |<RANGEDOTS: ".." >
    |<LOGIC_AND: "&&" >
    |<LOGIC_OR: "||" >
    |<SQUAREOPEN: "[" >
    |<SQUARECLOSE: "]" >
    |<COMMA: "," >
    |<EXCLAMATION: "!" >
    |<CURLYOPEN: "{" > { curlyDepth++; }
    |<CURLYCLOSE: "}" > { curlyDepth--; popIfCurly(); }
    |<PARENOPEN: "(" >
    |<PARENCLOSE: ")" >
    |<COLON: ":" >
    |<LT: "<" | "lt" | "\\lt" | "&lt;" >
    |<GT: "gt" | "\\gt" | "&gt;" >
    |<ASTERISK: "*">
    |<SLASH: "/" >
    |<PLUS: "+">
    |<MINUS: "-">
    |<PERCENT: "%">
    |<EQUALS: "=">
    |<QUESTIONMARK: "?" >
    |<AS: "as">
    |<IN: "in">
    |<IDENTIFIER: ["$","_","A"-"Z","a"-"z"](["$","_","A"-"Z","a"-"z","0"-"9"])* >
}

<EXPRESSION>
SKIP: {
      " " // <-- skipping spaces
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

<IN_RAW_STRING>
TOKEN:
{
    <RAW_STRING:  (~["\"" ])+>
}

<IN_RAW_STRING>
TOKEN:
{
    <END_RAW_STRING: "\""> { popState(); }
}

// TODO Expressions in String literals
<IN_SINGLE_STRING,IN_DUAL_STRING>
TOKEN:
{
     <ESC_DQUATOES: "\\\"" >
    |<ESC_SQUATES: "\\\'" >
    |<ESC_CURLOPEN: "\\{" >
    |<ESC_BACKSLASH: "\\\\" >
    |<ESC_NEWLINE: "\\n" >
    |<ESC_CRET: "\\r" >
    |<ESC_TAB: "\\t" >
    |<ESC_BACKSPACE: "\\b" >
    |<ESC_FORMFEED: "\\f" >
    |<ESC_LT: "\\l" >
    |<ESC_GT: "\\g" >
    |<ESC_AMP: "\\a" >
    |<ESC_UNICODE: "\\x" ["A"-"Z","a"-"z","0"-"9"]
                         ["A"-"Z","a"-"z","0"-"9"]
                        (["A"-"Z","a"-"z","0"-"9"]
                        (["A"-"Z","a"-"z","0"-"9"])?)?
     >
}


<IN_SINGLE_STRING>
TOKEN:
{
     <SINGLE_STRINGSEGMENT: (~["\\","\'" ])+ >
    |<END_SINGLE_STRING: "'" > { popState(); }
}

<IN_DUAL_STRING>
TOKEN:
{
     <DOUBLE_STRINGSEGMENT: (~["\\","\"" ])+ >
    |<END_DOUBLE_STRING: "\"" > { popState(); }
}

// START

Node Start():
{
	Node node;
}
{
	node = EmptySequence()
	<EOF>
	{ return node; }
}

void EndEmpty():
{}
{
	<TAG_END> | <EMPTY_TAG>
}

// TOP LEVEL PARSING

Node StringSequence():
{
	ConcatinationNode result = new ConcatinationNode();
	Node element;
}
{
	(  element = Content() { result.appendNode(element); }
	 | element = EmbeddedExpression() { result.appendNode(element); }
	 ) *
	 { return result; }
}


Node EmptySequence():
{
	ConcatinationNode result = new ConcatinationNode();
	Node element;
}
{
	(  element = Content() { result.appendNode(element); }
	 | element = Directive() { result.appendNode(element); }
	 | element = Macro() { result.appendNode(element); }
	 | element = EmbeddedExpression() { result.appendNode(element); }
	 ) *
	 { return result; }
}

Node Content():
{
	Token t;
	StringBuilder builder = new StringBuilder();
}
{
	t = <CONTENT>
	{ return new ValueNode(t.image); }
}


Node Macro():
{
}
{
	(<TAG_MACROCALL_START> Identifier() <TAG_END>
	    EmptySequence()
	<TAG_MACROCALL_END> Identifier() <TAG_END>
	)
	{ return EmptyNode.EMPTY_NODE; }
}


Node EmbeddedExpression():
{
	Node expression;
}
{
	<EXPRESSION_START> expression = Expression() <CURLYCLOSE>
	{ return expression; }
}



Node Directive():
{
	Node directive;
}
{
    (
		 directive = AssignDirective()
		 |directive = IfDirective()
	)
	{ return directive; }
}


// DIRECTIVES

Node AssignDirective():
{
    ConcatinationNode result = new ConcatinationNode();
    Node variable;
    Node value;
}
{
	<TAG_ASSIGN_START>
	(
		variable = VariableName()
		(( <EQUALS> value = Expression() { result.appendNode(new AssignNode(variable, value)); }
		  ( variable = VariableName() <EQUALS>  value = Expression()
		        { result.appendNode(new AssignNode(variable, value)); } )*
		  EndEmpty()
		)|(
		    <TAG_END>
		    value = EmptySequence() { result.appendNode(new AssignNode(variable, value)); }
		    <TAG_ASSIGN_STOP> <TAG_END>
		))
	)
	{ return result; }
}


Node IfDirective():
{
    List<ConditionalBlock> conditionals = new ArrayList<ConditionalBlock>();
    Node expression;
    Node block;
    Node elseBlock = null;
}
{
    <TAG_IF_START> expression = Expression() <TAG_END>
      block = EmptySequence() { conditionals.add(new ConditionalBlock(expression, block)); }
      (<TAG_ELSEIF_START> expression = Expression() <TAG_END>
           block = EmptySequence() { conditionals.add(new ConditionalBlock(expression, block)); })*
      (<TAG_ELSE_START> <TAG_END>
           elseBlock = EmptySequence())?
    <TAG_IF_STOP> <TAG_END>
    { return new ConditionalNode(conditionals, elseBlock); }
}


Node VariableName():
{
	Token t;
	Node node;
}
{
	( t = <IDENTIFIER> { node = new ValueNode(t.image); }
	| node = String() )
	{ return node; }
}


Node String():
{
	Node node = null;
	String content;
	Token t;
}
{
	(( t = <QUOTE_DOUBLE> content = SimpleString() <END_DOUBLE_STRING> {node = new ValueNode(content); })
	|( t = <QUOTE_SINGLE> content = SimpleString() <END_SINGLE_STRING> {node = new ValueNode(content); })
	|(<QUOTE_RAW> t = <RAW_STRING> <END_RAW_STRING> {node = new ValueNode(t.image); }))
	{ return node; }
}


String SimpleString():
{
    String segment;
	StringBuilder builder = new StringBuilder();
}
{
    ( segment = simpleStringSegment() { builder.append(segment); }
    )*
    { return builder.toString(); }
}

String simpleStringSegment():
{
    Token t;
    String segment;
}
{
    ( t = <DOUBLE_STRINGSEGMENT> { segment = t.image; }
	| t = <SINGLE_STRINGSEGMENT> { segment = t.image; }
    | <ESC_DQUATOES> { segment = "\""; }
    | <ESC_SQUATES> { segment = "\'"; }
    | <ESC_CURLOPEN> { segment = "{"; }
    | <ESC_BACKSLASH> { segment = "\\"; }
    | <ESC_NEWLINE> { segment = "\n"; }
    | <ESC_CRET> { segment = "\r"; }
    | <ESC_TAB> { segment = "\r"; }
    | <ESC_BACKSPACE> { segment = "\b"; }
    | <ESC_FORMFEED> { segment = "\f"; }
    | <ESC_LT> { segment = "<"; }
    | <ESC_GT> { segment = ">"; }
    | <ESC_AMP> { segment = "&"; }
    | t = <ESC_UNICODE> { segment = parseEscape(t.image); }
    )
    { return segment; }
}

// EXPRESSIONS


Node Expression():
{
	Node node;
}
{
	( node = Identifier()
	| node = String()
	)

	{ return node; }
}


Node Identifier():
{
	Token t;
}
{
	t = <IDENTIFIER>
	{ return new IdentifierNode(t.image); }
}
