options {
    STATIC = false;
}

PARSER_BEGIN(SpeedMarkerParser)
package de.soapwars.speedmarker;

import de.soapwars.speedmarker.ast.*;

public class SpeedMarkerParser extends SpeedMarkerParserBase {
}

PARSER_END(SpeedMarkerParser)

TOKEN_MGR_DECLS : {
    int curlyDepth = 0 ;
    java.util.List<StateBean> stateStack = new java.util.ArrayList<StateBean>();

    protected void pushState(int state) {
        stateStack.add(new StateBean(curLexState, curlyDepth));
        SwitchTo(state);
    }

    protected void popState() {
      SwitchTo(stateStack.remove(stateStack.size()-1).state);
    }

    protected void popIfCurly() {
        StateBean top = stateStack.get(stateStack.size()-1);
        if(curlyDepth == top.curly) popState();
    }
}

<DEFAULT>
SPECIAL_TOKEN:
{
    <NOPARSE_START: "<#noparse>"> { pushState(NOPARSE); }
}

<DEFAULT>
TOKEN:
{
    <DIRECTIVE_START: "<#" > : DIRECTIVE
    |<DIRECTIVE_END: "</#" > : DIRECTIVE
    |<MACRO_START: "<@">  { pushState(EXPRESSION); }
    |<MACRO_END: "</@">  { pushState(EXPRESSION); }
    |<EXPRESSION_START: "${" >  { pushState(EXPRESSION); curlyDepth++; }
    |<CONTENT: (~["<","$"])+ | ~[]>
}


<NOPARSE>
SPECIAL_TOKEN:
{
    <NOPARSE_END: "</#noparse>"> { popState(); }
}

<NOPARSE>
TOKEN:
{
    <UNPARSED_CONTENT: (~["<"])+ | ~[]>
}

<DIRECTIVE>
TOKEN: {
     <ASSIGN: "assign"> { pushState(EXPRESSION); }
    |<ATTEMPT: "attempt"> { pushState(EXPRESSION); }
    |<BREAK: "break" > { pushState(EXPRESSION); }
    |<CASE: "case"> { pushState(EXPRESSION); }
    |<COMPRESS: "compress"> { pushState(EXPRESSION); }
    |<DEFAULT_TAG: "default"> { pushState(EXPRESSION); }
    |<ELSE: "else"> { pushState(EXPRESSION); }
    |<ELSEIF: "elseif"> { pushState(EXPRESSION); }
    |<ESCAPE: "escape"> { pushState(EXPRESSION); }
    |<FALLBACK: "fallback"> { pushState(EXPRESSION); }
    |<FUNCTION: "function"> { pushState(EXPRESSION); }
    |<FLUSH: "flush"> { pushState(EXPRESSION); }
    |<FTL: "ftl"> { pushState(EXPRESSION); }
    |<GLOBAL: "global"> { pushState(EXPRESSION); }
    |<IF: "if"> { pushState(EXPRESSION); }
    |<IMPORT: "import"> { pushState(EXPRESSION); }
    |<INCLUDE: "include"> { pushState(EXPRESSION); }
    |<LIST: "list"> { pushState(EXPRESSION); }
    |<LOCAL: "local"> { pushState(EXPRESSION); }
    |<LT_TAG: "lt"> { pushState(EXPRESSION); }
    |<MACRO_TAG: "macro"> { pushState(EXPRESSION); }
    |<NESTED: "nested"> { pushState(EXPRESSION); }
    |<NOESCAPE: "noescape"> { pushState(EXPRESSION); }
    |<NT: "nt" > { pushState(EXPRESSION); }
    |<RECOVER: "recover" > { pushState(EXPRESSION); }
    |<RECURSE: "recurse" > { pushState(EXPRESSION); }
    |<RETURN: "return" > { pushState(EXPRESSION); }
    |<RT: "rt" > { pushState(EXPRESSION); }
    |<SETTING: "setting" > { pushState(EXPRESSION); }
    |<STOP: "stop" > { pushState(EXPRESSION); }
    |<SWITCH: "switch" > { pushState(EXPRESSION); }
    |<T_TAG: "t" > { pushState(EXPRESSION); }
    |<VISIT: "visit" > { pushState(EXPRESSION); }
}

<EXPRESSION>
TOKEN:
{
     <TAG_END: ">"> { popState(); }
    |<EMPTY_TAG: "/>"> { popState(); }
}
<EXPRESSION>
MORE:
{
     < "r\"" > { pushState(IN_RAW_STRING); }
    |< "\"" > { pushState(IN_DUAL_STRING); }
    |< "'" >  { pushState(IN_SINGLE_STRING); }
}

<EXPRESSION>
TOKEN:
{
     <NUMBERLITERAL: (["0"-"9"])+("."(["0"-"9"])+)? >
    |<BOOLEANLITERAL: "true" | "false" >
    |<DOUBLEQUEST: "??" >
    |<EQUALS: "==" >
    |<NOT_EQUALS: "!=" >
    |<LTE: "lte" | "\\lte" | "<=" | "&lt;=" >
    |<GTE: "gte" | "\\gte"  | "&gt;=" >
    |<RANGEDOTS: ".." >
    |<LOGIC_AND: "&&" >
    |<LOGIC_OR: "||" >
    |<SQUAREOPEN: "[" >
    |<SQUARECLOSE: "]" >
    |<COMMA: "," >
    |<EXCLAMATION: "!" >
    |<CURLYOPEN: "{" > { curlyDepth++; }
    |<CURLYCLOSE: "}" > { curlyDepth--; popIfCurly(); }
    |<PARENOPEN: "(" >
    |<PARENCLOSE: ")" >
    |<COLON: ":" >
    |<LT: "<" | "lt" | "\\lt" | "&lt;" >
    |<GT: "gt" | "\\gt" | "&gt;" >
    |<ASTERISK: "*">
    |<SLASH: "/" >
    |<PLUS: "+">
    |<MINUS: "-">
    |<PERCENT: "%">
    |<QUESTIONMARK: "?" >
    |<IDENTIFIER: ["$","_","A"-"Z","a"-"z"](["$","_","A"-"Z","a"-"z","0"-"9"])* >
}

<EXPRESSION>
SKIP: {
      " " // <-- skipping spaces
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

<IN_RAW_STRING>
MORE:
{
    < ~["\"" ] >
}

<IN_RAW_STRING>
TOKEN:
{
    <RAWSTRING: "\""> { popState(); }
}

// TODO Expressions in String literals
<IN_SINGLE_STRING,IN_DUAL_STRING>
TOKEN:
{   <STRING_EXPRESSION_START: "${"> { pushState(EXPRESSION); curlyDepth++; }
    |<ESC_DQUATOES: "\\\"" >
    |<ESC_SQUATES: "\\\'" >
    |<ESC_CURLOPEN: "\\{" >
    |<ESC_BACKSLASH: "\\\\" >
    |<ESC_NEWLINE: "\\n" >
    |<ESC_CRET: "\\r" >
    |<ESC_TAB: "\\t" >
    |<ESC_BACKSPACE: "\\b" >
    |<ESC_FORMFEED: "\\f" >
    |<ESC_LT: "\\l" >
    |<ESC_GT: "\\g" >
    |<ESC_AMP: "\\a" >
    |<ESC_UNICODE: "\\x" ["A"-"Z","a"-"z","0"-"9"]
                         ["A"-"Z","a"-"z","0"-"9"]
                        (["A"-"Z","a"-"z","0"-"9"]
                        (["A"-"Z","a"-"z","0"-"9"])?)?
     >
}

<IN_SINGLE_STRING>
TOKEN:
{
     <SINGLE_STRINGSEGMENT: (~["\\","\'", "$"])+ >
    |<END_SINGLE_STRING: "'" > { popState(); }
}

<IN_DUAL_STRING>
TOKEN:
{
     <DOUBLE_STRINGSEGMENT: (~["\\","\"", "$"])+ >
    |<END_DOUBLE_STRING: "\"" > { popState(); }
}


Node Start():
{
    Node n;
}
{
        n = Sequence()
        <EOF>
        { return n; }

}

Node Sequence():
{
    SequenceNode n = new SequenceNode();
}
{
      (Content(n)
    | ContentExpression(n)
    | Directive(n)
    | Macro(n))
    { return n; }
}

void Content(SequenceNode sn):
{
    Token t;
    StringBuilder builder = new StringBuilder();
}
{
    ( t = <CONTENT> { builder.append(t.image); })+
      { sn.addNode(new ContentNode(builder.toString())); }
    (  ContentExpression(sn)
     | Directive(sn)
     | Macro(sn)
    )?
}

void ContentExpression(SequenceNode sn):
{
    Node n;
}
{
    (<EXPRESSION_START> n = Expression() <CURLYCLOSE>
        { sn.addNode(n); })+
    (  Content(sn)
     | Directive(sn)
     | Macro(sn)
    )?
}

void Directive(SequenceNode sn):
{
}
{
    (<DIRECTIVE_START> (
          IfBlock()
        | AssignBlock()
    )
    )+
   (  Content(sn)
    | ContentExpression(sn)
    | Macro(sn)
   )?
}

void Macro(SequenceNode sn):
{
}
{
    (<MACRO_START>)+
   (  Content(sn)
    | ContentExpression(sn)
    | Directive(sn)
   )?
}

// DIRECTIVES

Node IfBlock():
{
    Node condition;
}
{
    <IF> condition = Expression() <CURLYCLOSE>
    (
        Sequence()
        <ELSEIF> Expression() <CURLYCLOSE>
    )*
    (
        <ELSE> <EMPTY_TAG>
        Sequence()
    )?
    Sequence()
    <DIRECTIVE_END> <IF> <CURLYCLOSE>
    { return null; }
}

Node AssignBlock():
{}
{
    <ASSIGN> <EMPTY_TAG>
    { return null; }
}



// EXPRESSION

Node Expression():
{
    Token t;
}
{
    t = <IDENTIFIER> { return new IdentifierNode(t.image); }
}