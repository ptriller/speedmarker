options {
    STATIC = false;
	DEBUG_PARSER = true;
}

PARSER_BEGIN(SpeedMarkerParser)
package de.soapwars.speedmarker;

import de.soapwars.speedmarker.ast.*;

public class SpeedMarkerParser extends SpeedMarkerParserBase {
}

PARSER_END(SpeedMarkerParser)

TOKEN_MGR_DECLS : {
    int curlyDepth = 0 ;
    java.util.List<StateBean> stateStack = new java.util.ArrayList<StateBean>();

	protected void swapState(int state) {
		popState();
		pushState(state);
	}

    protected void pushState(int state) {
        stateStack.add(new StateBean(curLexState, curlyDepth));
        SwitchTo(state);
    }

    protected void popState() {
      int state = stateStack.remove(stateStack.size()-1).state;
      SwitchTo(state);
    }

    protected void popIfCurly() {
        StateBean top = stateStack.get(stateStack.size()-1);
        if(curlyDepth == top.curly) popState();
    }
}

<DEFAULT>
SPECIAL_TOKEN:
{
    <NOPARSE_START: "<#noparse>"> { pushState(NOPARSE); }
}

<DEFAULT>
TOKEN:
{
	 <TAG_DIRECTIVE_START: "<#"> { pushState(DIRECTIVE); }
	|<TAG_DIRECTIVE_END: "</#"> { pushState(DIRECTIVE); }
    |<TAG_MACRO_START: "<@">  { pushState(EXPRESSION); }
    |<TAG_MACRO_END: "</@">  { pushState(EXPRESSION); }
    |<EXPRESSION_START: "${" >  { pushState(EXPRESSION); curlyDepth++; }
    |<CONTENT: (~["<","$"])+ | ~[]>
}


<NOPARSE>
SPECIAL_TOKEN:
{
    <NOPARSE_END: "</#noparse>"> { popState(); }
}

<NOPARSE>
TOKEN:
{
    <UNPARSED_CONTENT: (~["<"])+ | ~[]>
}

<DIRECTIVE>
TOKEN: {
    <TAG_ASSIGN: "assign"> { swapState(EXPRESSION); }
    |<TAG_ATTEMPT: "attempt"> { swapState(EXPRESSION); }
    |<TAG_BREAK: "break" > { swapState(EXPRESSION); }
    |<TAG_CASE: "case"> { swapState(EXPRESSION); }
    |<TAG_COMPRESS: "compress"> { swapState(EXPRESSION); }
    |<TAG_DEFAULT: "default"> { swapState(EXPRESSION); }
    |<TAG_ELSE: "else"> { swapState(EXPRESSION); }
    |<TAG_ELSEIF: "elseif"> { swapState(EXPRESSION); }
    |<TAG_ESCAPE: "escape"> { swapState(EXPRESSION); }
    |<TAG_FALLBACK: "fallback"> { swapState(EXPRESSION); }
    |<TAG_FUNCTION: "function"> { swapState(EXPRESSION); }
    |<TAG_FLUSH: "flush"> { swapState(EXPRESSION); }
    |<TAG_FTL: "ftl"> { swapState(EXPRESSION); }
    |<TAG_GLOBAL: "global"> { swapState(EXPRESSION); }
    |<TAG_IF: "if"> { swapState(EXPRESSION); }
    |<TAG_IMPORT: "import"> { swapState(EXPRESSION); }
    |<TAG_INCLUDE: "include"> { swapState(EXPRESSION); }
    |<TAG_LIST: "list"> { swapState(EXPRESSION); }
    |<TAG_LOCAL: "local"> { swapState(EXPRESSION); }
    |<TAG_LT: "lt"> { swapState(EXPRESSION); }
    |<TAG_MACRO: "macro"> { swapState(EXPRESSION); }
    |<TAG_NESTED: "nested"> { swapState(EXPRESSION); }
    |<TAG_NOESCAPE: "noescape"> { swapState(EXPRESSION); }
    |<TAG_NT: "nt" > { swapState(EXPRESSION); }
    |<TAG_RECOVER: "recover" > { swapState(EXPRESSION); }
    |<TAG_RECURSE: "recurse" > { swapState(EXPRESSION); }
    |<TAG_RETURN: "return" > { swapState(EXPRESSION); }
    |<TAG_RT: "rt" > { swapState(EXPRESSION); }
    |<TAG_SETTING: "setting" > { swapState(EXPRESSION); }
    |<TAG_STOP: "stop" > { swapState(EXPRESSION); }
    |<TAG_SWITCH: "switch" > { swapState(EXPRESSION); }
    |<TAG_T: "t" > { swapState(EXPRESSION); }
    |<TAG_VISIT: "visit" > { swapState(EXPRESSION); }
}

<EXPRESSION>
TOKEN:
{
     <TAG_END: ">"> { popState(); }
    |<EMPTY_TAG: "/>"> { popState(); }
}
<EXPRESSION>
TOKEN:
{
     <QUOTE_RAW:  "r\"" > { pushState(IN_RAW_STRING); }
    |<QUOTE_DOUBLE: "\"" > { pushState(IN_DUAL_STRING); }
    |<QUOTE_SINGLE: "'" >  { pushState(IN_SINGLE_STRING); }
}

<EXPRESSION>
TOKEN:
{
     <NUMBERLITERAL: (["0"-"9"])+("."(["0"-"9"])+)? >
    |<BOOLEANLITERAL: "true" | "false" >
    |<DOUBLEQUEST: "??" >
    |<COMPARE: "==" >
    |<NOT_EQUALS: "!=" >
    |<LTE: "lte" | "\\lte" | "<=" | "&lt;=" >
    |<GTE: "gte" | "\\gte"  | "&gt;=" >
    |<RANGEDOTS: ".." >
    |<LOGIC_AND: "&&" >
    |<LOGIC_OR: "||" >
    |<SQUAREOPEN: "[" >
    |<SQUARECLOSE: "]" >
    |<COMMA: "," >
    |<EXCLAMATION: "!" >
    |<CURLYOPEN: "{" > { curlyDepth++; }
    |<CURLYCLOSE: "}" > { curlyDepth--; popIfCurly(); }
    |<PARENOPEN: "(" >
    |<PARENCLOSE: ")" >
    |<COLON: ":" >
    |<LT: "<" | "lt" | "\\lt" | "&lt;" >
    |<GT: "gt" | "\\gt" | "&gt;" >
    |<ASTERISK: "*">
    |<SLASH: "/" >
    |<PLUS: "+">
    |<MINUS: "-">
    |<PERCENT: "%">
    |<EQUALS: "=">
    |<QUESTIONMARK: "?" >
    |<AS: "as">
    |<IN: "in">
    |<IDENTIFIER: ["$","_","A"-"Z","a"-"z"](["$","_","A"-"Z","a"-"z","0"-"9"])* >
}

<EXPRESSION>
SKIP: {
      " " // <-- skipping spaces
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

<IN_RAW_STRING>
MORE:
{
    < ~["\"" ] >
}

<IN_RAW_STRING>
TOKEN:
{
    <RAWSTRING: "\""> { popState(); }
}

// TODO Expressions in String literals
<IN_SINGLE_STRING,IN_DUAL_STRING>
TOKEN:
{   <STRING_EXPRESSION_START: "${"> { pushState(EXPRESSION); curlyDepth++; }
    |<ESC_DQUATOES: "\\\"" >
    |<ESC_SQUATES: "\\\'" >
    |<ESC_CURLOPEN: "\\{" >
    |<ESC_BACKSLASH: "\\\\" >
    |<ESC_NEWLINE: "\\n" >
    |<ESC_CRET: "\\r" >
    |<ESC_TAB: "\\t" >
    |<ESC_BACKSPACE: "\\b" >
    |<ESC_FORMFEED: "\\f" >
    |<ESC_LT: "\\l" >
    |<ESC_GT: "\\g" >
    |<ESC_AMP: "\\a" >
    |<ESC_UNICODE: "\\x" ["A"-"Z","a"-"z","0"-"9"]
                         ["A"-"Z","a"-"z","0"-"9"]
                        (["A"-"Z","a"-"z","0"-"9"]
                        (["A"-"Z","a"-"z","0"-"9"])?)?
     >
}

<IN_SINGLE_STRING>
TOKEN:
{
     <SINGLE_STRINGSEGMENT: (~["\\","\'", "$"])+ >
    |<END_SINGLE_STRING: "'" > { popState(); }
}

<IN_DUAL_STRING>
TOKEN:
{
     <DOUBLE_STRINGSEGMENT: (~["\\","\"", "$"])+ >
    |<END_DOUBLE_STRING: "\"" > { popState(); }
}

// START

Node Start():
{
	Node node;
}
{
	node = EmptySequence()
	<EOF>
	{ return node; }
}

void EndEmpty():
{}
{
	<TAG_END> | <EMPTY_TAG>
}

// TOP LEVEL PARSING


Node EmptySequence():
{
	Node node = EmptyNode.EMPTY_NODE;
}
{
	(  node = Content()
	 | node = Directive()
	 | node = Macro()
	 | node = EmbeddedExpression()
	 ) ?
	 { return node; }
}

SequenceNode Content():
{
	Token t;
	StringBuilder builder = new StringBuilder();
	SequenceNode node = SequenceNode.EMPTY_SEQUENCE;
}
{
	( t = <CONTENT> { builder.append(t.image); } )+
	( node = Directive()
	| node = Macro()
	| node = EmbeddedExpression()
	)?
	{ return new SequenceNode(node, new ContentNode(builder.toString())); }
}


SequenceNode Macro():
{
	SequenceNode node = SequenceNode.EMPTY_SEQUENCE;
}
{
	<TAG_MACRO_START> Identifier() <TAG_END><TAG_MACRO_END> Identifier() <TAG_END>
	(
	  node = Content()
	| node = Directive()
	| node = EmbeddedExpression()
	)?
	{ return new SequenceNode(node, EmptyNode.EMPTY_NODE); }
}


SequenceNode EmbeddedExpression():
{
	Node expression;
	SequenceNode node = SequenceNode.EMPTY_SEQUENCE;
}
{
	<EXPRESSION_START> expression = Expression() <CURLYCLOSE>
	(
	  node = Content()
	| node = Directive()
	| node = Macro()
	)?
	{ return new SequenceNode(node, expression); }
}



SequenceNode Directive():
{
	SequenceNode node = SequenceNode.EMPTY_SEQUENCE;
}
{
	<TAG_DIRECTIVE_START> (
		AssignDirective()
	)
	(
	  node = Content()
	| node = Macro()
	| node = EmbeddedExpression()
	)?
	{ return new SequenceNode(node, EmptyNode.EMPTY_NODE); }
}


// DIRECTIVES

Node AssignDirective():
{
}
{
	<TAG_ASSIGN>
	(
		VariableName()
		( <EQUALS> Expression() ( VariableName() <EQUALS> Expression() )*
		  EndEmpty()
		)
	)
	{ return EmptyNode.EMPTY_NODE; }
}



Node VariableName():
{
	Token t;
	Node node;
}
{
	t = <IDENTIFIER> { node = new StringNode(t.image); }
	{ return node; }
}


Node String():
{
	Node node;
}
{
	<QUOTE_DOUBLE> node = StringContent() <END_DOUBLE_STRING>
	{ return node; }
}


Node StringContent():
{
	Token t;
	StringBuilder builder = new StringBuilder();
}
{
	( t = <DOUBLE_STRINGSEGMENT> { builder.append(t.image); }
	| t = <SINGLE_STRINGSEGMENT> { builder.append(t.image); }
    | <ESC_DQUATOES> { builder.append('"'); }
    | <ESC_SQUATES> { builder.append('\''); }
    | <ESC_CURLOPEN> { builder.append('{'); }
    |<ESC_BACKSLASH> { builder.append('\\'); }
    |<ESC_NEWLINE> { builder.append('\n'); }
    |<ESC_CRET> { builder.append('\r'); }
    |<ESC_TAB> { builder.append('\r'); }
    |<ESC_BACKSPACE> { builder.append('\b'); }
    |<ESC_FORMFEED> { builder.append('\f'); }
    |<ESC_LT> { builder.append('<'); }
    |<ESC_GT> { builder.append('>'); }
    |<ESC_AMP> { builder.append('&'); }
    |<ESC_UNICODE> { builder.append('?'); } // TODO
    )*
    { return new StringNode(builder.toString()); }
}

// EXPRESSIONS

Node Expression():
{
	Node node;
}
{
	( node = Identifier()
	| node = String()
	)

	{ return node; }
}


Node Identifier():
{
	Token t;
}
{
	t = <IDENTIFIER>
	{ return new IdentifierNode(t.image); }
}
