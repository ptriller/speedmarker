options {
    STATIC = false;
	DEBUG_PARSER = true;
}

PARSER_BEGIN(SpeedMarkerParser)
package de.soapwars.speedmarker;

import de.soapwars.speedmarker.ast.*;

public class SpeedMarkerParser extends SpeedMarkerParserBase {
}

PARSER_END(SpeedMarkerParser)

TOKEN_MGR_DECLS : {
    int curlyDepth = 0 ;
    java.util.List<StateBean> stateStack = new java.util.ArrayList<StateBean>();

	protected void swapState(int state) {
		popState();
		pushState(state);
	}

    protected void pushState(int state) {
        stateStack.add(new StateBean(curLexState, curlyDepth));
        SwitchTo(state);
    }

    protected void popState() {
      int state = stateStack.remove(stateStack.size()-1).state;
      SwitchTo(state);
    }

    protected void popIfCurly() {
        StateBean top = stateStack.get(stateStack.size()-1);
        if(curlyDepth == top.curly) popState();
    }
}

<DEFAULT>
SPECIAL_TOKEN:
{
    <NOPARSE_START: "<#noparse>"> { pushState(NOPARSE); }
}

<DEFAULT>
TOKEN:
{
	 <TAG_DIRECTIVE_START: "<#"> { pushState(DIRECTIVE); }
	|<TAG_DIRECTIVE_END: "</#"> { pushState(DIRECTIVE); }
    |<TAG_MACRO_START: "<@">  { pushState(EXPRESSION); }
    |<TAG_MACRO_END: "</@">  { pushState(EXPRESSION); }
    |<EXPRESSION_START: "${" >  { pushState(EXPRESSION); curlyDepth++; }
    |<CONTENT: (~["<","$"])+ | ~[]>
}


<NOPARSE>
SPECIAL_TOKEN:
{
    <NOPARSE_END: "</#noparse>"> { popState(); }
}

<NOPARSE>
TOKEN:
{
    <UNPARSED_CONTENT: (~["<"])+ | ~[]>
}

<DIRECTIVE>
TOKEN: {
    <TAG_ASSIGN: "assign"> { swapState(EXPRESSION); }
    |<TAG_ATTEMPT: "attempt"> { swapState(EXPRESSION); }
    |<TAG_BREAK: "break" > { swapState(EXPRESSION); }
    |<TAG_CASE: "case"> { swapState(EXPRESSION); }
    |<TAG_COMPRESS: "compress"> { swapState(EXPRESSION); }
    |<TAG_DEFAULT: "default"> { swapState(EXPRESSION); }
    |<TAG_ELSE: "else"> { swapState(EXPRESSION); }
    |<TAG_ELSEIF: "elseif"> { swapState(EXPRESSION); }
    |<TAG_ESCAPE: "escape"> { swapState(EXPRESSION); }
    |<TAG_FALLBACK: "fallback"> { swapState(EXPRESSION); }
    |<TAG_FUNCTION: "function"> { swapState(EXPRESSION); }
    |<TAG_FLUSH: "flush"> { swapState(EXPRESSION); }
    |<TAG_FTL: "ftl"> { swapState(EXPRESSION); }
    |<TAG_GLOBAL: "global"> { swapState(EXPRESSION); }
    |<TAG_IF: "if"> { swapState(EXPRESSION); }
    |<TAG_IMPORT: "import"> { swapState(EXPRESSION); }
    |<TAG_INCLUDE: "include"> { swapState(EXPRESSION); }
    |<TAG_LIST: "list"> { swapState(EXPRESSION); }
    |<TAG_LOCAL: "local"> { swapState(EXPRESSION); }
    |<TAG_LT: "lt"> { swapState(EXPRESSION); }
    |<TAG_MACRO: "macro"> { swapState(EXPRESSION); }
    |<TAG_NESTED: "nested"> { swapState(EXPRESSION); }
    |<TAG_NOESCAPE: "noescape"> { swapState(EXPRESSION); }
    |<TAG_NT: "nt" > { swapState(EXPRESSION); }
    |<TAG_RECOVER: "recover" > { swapState(EXPRESSION); }
    |<TAG_RECURSE: "recurse" > { swapState(EXPRESSION); }
    |<TAG_RETURN: "return" > { swapState(EXPRESSION); }
    |<TAG_RT: "rt" > { swapState(EXPRESSION); }
    |<TAG_SETTING: "setting" > { swapState(EXPRESSION); }
    |<TAG_STOP: "stop" > { swapState(EXPRESSION); }
    |<TAG_SWITCH: "switch" > { swapState(EXPRESSION); }
    |<TAG_T: "t" > { swapState(EXPRESSION); }
    |<TAG_VISIT: "visit" > { swapState(EXPRESSION); }
}

<EXPRESSION>
TOKEN:
{
     <TAG_END: ">"> { popState(); }
    |<EMPTY_TAG: "/>"> { popState(); }
}
<EXPRESSION>
TOKEN:
{
     <QUOTE_RAW:  "r\"" > { pushState(IN_RAW_STRING); }
    |<QUOTE_DOUBLE: "\"" > { pushState(IN_DUAL_STRING); }
    |<QUOTE_SINGLE: "'" >  { pushState(IN_SINGLE_STRING); }
}

<EXPRESSION>
TOKEN:
{
     <NUMBERLITERAL: (["0"-"9"])+("."(["0"-"9"])+)? >
    |<BOOLEANLITERAL: "true" | "false" >
    |<DOUBLEQUEST: "??" >
    |<COMPARE: "==" >
    |<NOT_EQUALS: "!=" >
    |<LTE: "lte" | "\\lte" | "<=" | "&lt;=" >
    |<GTE: "gte" | "\\gte"  | "&gt;=" >
    |<RANGEDOTS: ".." >
    |<LOGIC_AND: "&&" >
    |<LOGIC_OR: "||" >
    |<SQUAREOPEN: "[" >
    |<SQUARECLOSE: "]" >
    |<COMMA: "," >
    |<EXCLAMATION: "!" >
    |<CURLYOPEN: "{" > { curlyDepth++; }
    |<CURLYCLOSE: "}" > { curlyDepth--; popIfCurly(); }
    |<PARENOPEN: "(" >
    |<PARENCLOSE: ")" >
    |<COLON: ":" >
    |<LT: "<" | "lt" | "\\lt" | "&lt;" >
    |<GT: "gt" | "\\gt" | "&gt;" >
    |<ASTERISK: "*">
    |<SLASH: "/" >
    |<PLUS: "+">
    |<MINUS: "-">
    |<PERCENT: "%">
    |<EQUALS: "=">
    |<QUESTIONMARK: "?" >
    |<AS: "as">
    |<IN: "in">
    |<IDENTIFIER: ["$","_","A"-"Z","a"-"z"](["$","_","A"-"Z","a"-"z","0"-"9"])* >
}

<EXPRESSION>
SKIP: {
      " " // <-- skipping spaces
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

<IN_RAW_STRING>
TOKEN:
{
    <RAW_STRING:  (~["\"" ])+>
}

<IN_RAW_STRING>
TOKEN:
{
    <END_RAW_STRING: "\""> { popState(); }
}

// TODO Expressions in String literals
<IN_SINGLE_STRING,IN_DUAL_STRING>
TOKEN:
{
     <ESC_DQUATOES: "\\\"" >
    |<ESC_SQUATES: "\\\'" >
    |<ESC_CURLOPEN: "\\{" >
    |<ESC_BACKSLASH: "\\\\" >
    |<ESC_NEWLINE: "\\n" >
    |<ESC_CRET: "\\r" >
    |<ESC_TAB: "\\t" >
    |<ESC_BACKSPACE: "\\b" >
    |<ESC_FORMFEED: "\\f" >
    |<ESC_LT: "\\l" >
    |<ESC_GT: "\\g" >
    |<ESC_AMP: "\\a" >
    |<ESC_UNICODE: "\\x" ["A"-"Z","a"-"z","0"-"9"]
                         ["A"-"Z","a"-"z","0"-"9"]
                        (["A"-"Z","a"-"z","0"-"9"]
                        (["A"-"Z","a"-"z","0"-"9"])?)?
     >
}


<IN_SINGLE_STRING>
TOKEN:
{
     <SINGLE_STRINGSEGMENT: (~["\\","\'" ])+ >
    |<END_SINGLE_STRING: "'" > { popState(); }
}

<IN_DUAL_STRING>
TOKEN:
{
     <DOUBLE_STRINGSEGMENT: (~["\\","\"" ])+ >
    |<END_DOUBLE_STRING: "\"" > { popState(); }
}

// START

Node Start():
{
	Node node;
}
{
	node = EmptySequence()
	<EOF>
	{ return node; }
}

void EndEmpty():
{}
{
	<TAG_END> | <EMPTY_TAG>
}

// TOP LEVEL PARSING


ConcatinationNode EmptySequence():
{
	ConcatinationNode node = new ConcatinationNode();;
}
{
	(  node = Content()
	 | node = Directive()
	 | node = Macro()
	 | node = EmbeddedExpression()
	 ) ?
	 { return node; }
}

ConcatinationNode Content():
{
	Token t;
	StringBuilder builder = new StringBuilder();
	ConcatinationNode result = new ConcatinationNode();
	ConcatinationNode node;
}
{
	( t = <CONTENT> { builder.append(t.image); } )+
	{ result.appendNode(new ValueNode(builder.toString())); }
	( node = Directive() { result.appendAll(node); }
	| node = Macro() { result.appendAll(node); }
	| node = EmbeddedExpression() { result.appendAll(node); }
	)?
	{ return result; }
}


ConcatinationNode Macro():
{
	ConcatinationNode result = new ConcatinationNode();
	ConcatinationNode node;
}
{
	(<TAG_MACRO_START> Identifier() <TAG_END>
	    EmptySequence()
	<TAG_MACRO_END> Identifier() <TAG_END>
	)+
	(
	  node = Content(){ result.appendAll(node); }
	| node = Directive() { result.appendAll(node); }
	| node = EmbeddedExpression() { result.appendAll(node); }
	)?
	{ return result; }
}


ConcatinationNode EmbeddedExpression():
{
	Node expression;
	ConcatinationNode result = new ConcatinationNode();
	ConcatinationNode node;
}
{
	(<EXPRESSION_START> expression = Expression() <CURLYCLOSE>
	 { result.appendNode(expression); }
	)+
	(
	  node = Content() { result.appendAll(node); }
	| node = Directive() { result.appendAll(node); }
	| node = Macro() { result.appendAll(node); }
	)?
	{ return result; }
}



ConcatinationNode Directive():
{
	ConcatinationNode result = new ConcatinationNode();
	ConcatinationNode node;
	Node directive;
}
{
	(<TAG_DIRECTIVE_START> (
		 directive = AssignDirective() { result.appendNode(directive); }
		 |directive = IfDirective() { result.appendNode(directive); }
	))+
	(
	  node = Content() { result.appendAll(node); }
	| node = Macro() { result.appendAll(node); }
	| node = EmbeddedExpression() { result.appendAll(node); }
	)?
	{ return result; }
}


// DIRECTIVES

Node AssignDirective():
{
    ConcatinationNode result = new ConcatinationNode();
    Node variable;
    Node value;
}
{
	<TAG_ASSIGN>
	(
		variable = VariableName()
		(( <EQUALS> value = Expression() { result.appendNode(new AssignNode(variable, value)); }
		  ( variable = VariableName() <EQUALS>  value = Expression()
		        { result.appendNode(new AssignNode(variable, value)); } )*
		  EndEmpty()
		)|(
		    <TAG_END>
		    value = EmptySequence() { result.appendNode(new AssignNode(variable, value)); }
		    <TAG_DIRECTIVE_END> <TAG_ASSIGN> <TAG_END>
		))
	)
	{ return result; }
}


Node IfDirective():
{
}
{
    <TAG_IF> Expression() <TAG_END>
      EmptySequence()
     (<TAG_DIRECTIVE_START>
        ElseIfDirective()
        |ElseDirective()
     )
    |(<TAG_DIRECTIVE_END> <TAG_IF> <TAG_END>)
    { return EmptyNode.EMPTY_NODE; }
}

Node ElseIfDirective():
{
}
{
    <TAG_ELSEIF> Expression() <TAG_END>
    EmptySequence()
    (<TAG_DIRECTIVE_START>
        ElseIfDirective()
        |ElseDirective()
    )?
    { return EmptyNode.EMPTY_NODE; }
}

Node ElseDirective():
{
}
{
    <TAG_ELSE> <TAG_END>
    EmptySequence()
   { return EmptyNode.EMPTY_NODE; }
}


Node VariableName():
{
	Token t;
	Node node;
}
{
	( t = <IDENTIFIER> { node = new ValueNode(t.image); }
	| node = String() )
	{ return node; }
}


Node String():
{
	Node node = null;
	String content;
	Token t;
}
{
	(( t = <QUOTE_DOUBLE> content = SimpleString() <END_DOUBLE_STRING> {node = new ValueNode(content); })
	|( t = <QUOTE_SINGLE> content = SimpleString() <END_SINGLE_STRING> {node = new ValueNode(content); })
	|(<QUOTE_RAW> t = <RAW_STRING> <END_RAW_STRING> {node = new ValueNode(t.image); }))
	{ return node; }
}


String SimpleString():
{
    String segment;
	StringBuilder builder = new StringBuilder();
}
{
    ( segment = simpleStringSegment() { builder.append(segment); }
    )*
    { return builder.toString(); }
}

String simpleStringSegment():
{
    Token t;
    String segment;
}
{
    ( t = <DOUBLE_STRINGSEGMENT> { segment = t.image; }
	| t = <SINGLE_STRINGSEGMENT> { segment = t.image; }
    | <ESC_DQUATOES> { segment = "\""; }
    | <ESC_SQUATES> { segment = "\'"; }
    | <ESC_CURLOPEN> { segment = "{"; }
    | <ESC_BACKSLASH> { segment = "\\"; }
    | <ESC_NEWLINE> { segment = "\n"; }
    | <ESC_CRET> { segment = "\r"; }
    | <ESC_TAB> { segment = "\r"; }
    | <ESC_BACKSPACE> { segment = "\b"; }
    | <ESC_FORMFEED> { segment = "\f"; }
    | <ESC_LT> { segment = "<"; }
    | <ESC_GT> { segment = ">"; }
    | <ESC_AMP> { segment = "&"; }
    | t = <ESC_UNICODE> { segment = parseEscape(t.image); }
    )
    { return segment; }
}

// EXPRESSIONS


Node Expression():
{
	Node node;
}
{
	( node = Identifier()
	| node = String()
	)

	{ return node; }
}


Node Identifier():
{
	Token t;
}
{
	t = <IDENTIFIER>
	{ return new IdentifierNode(t.image); }
}
